/*
 * LuaError.cpp
 *
 *  Created on: 24 Aug. 2017
 *      Author: Brent
 */

#include <Lua/lua.hpp>
#include <Scripting/Lua/LuaError.h>
#include <iostream>

using namespace std;

LuaError::LuaError(lua_State *l) {

	this -> l = l;

	stackLevel = 2;
	errorLevel = ScriptResult::eResult_Vassal_Error;
	errorMessage = "";
	sourceName = "";
	sourceLine = 0;
}

LuaError::~LuaError() {
	// TODO Auto-generated destructor stub
}

/*
 * Read any existing Lua error object and the details of the the new error.
 * A Lua error object will exist already if this error is percolating upwards from nested script calls. If
 * a Lua error object exists, then the details in it take precedence over the arguments to raiseError
 */
void LuaError::build() {

	// cout << "LuaError::build: Number of args=" << lua_gettop(l) << endl;

	// Handle an error object by itself on top of the stack
	if (lua_istable (l, -1)) {
		// cout << "LuaError::build: Table on top of stack, extract data" << endl;
		extractSourceFromError(-1);
		lua_pop(l, lua_gettop(l));
		return;
	}

	int nargs = lua_gettop (l);

	if (nargs < 3 || ! lua_isinteger (l, 3)) {
		string error = "raiseError: Argument 3 is not an integer: ";
		error.append(lua_typename(l, lua_type(l, 3)));
		luaL_error (l, error.c_str());
	}
	stackLevel = lua_tointeger(l, 3);
	// cout << "LuaError::build: stackLevel=" << stackLevel << endl;

	if (nargs < 2 || ! lua_isinteger (l, 2)) {
		luaL_error (l, "raiseError: Argument 2 is not an integer");
	}
	errorLevel = (ScriptResult::eResult) lua_tointeger(l, 2);
	// cout << "LuaError::build: errorLevel=" << errorLevel << endl;

	// Is the error object a string?
	if (nargs > 0 && lua_isstring(l, 1)) {
		// cout << "LuaError::build: " << "error is string" << endl;

		string error = lua_tostring(l, 1);
		// cout << "LuaError::build: error string=" << error << endl;

		// Does the Error string already contain source information
		if (error[0] == '[') {
			// Extract the source information from the error string
			extractSourceFromString (error);
		}
		else {
			// No source info in error string, use the Lua debug module to find it
			extractSourceFromLua (error);
		}

	// Or is the error object a table?
	} else	if (nargs > 0 && lua_istable(l, 1)) {
		// cout << "LuaError::build Error object is table at 1" << endl;
		extractSourceFromError(1);

	} else {
		luaL_error (l, "raiseError: Argument 1 is neither a string or a table");
	}

	// sourceName may have been supplied as a 4th argument
	if (nargs > 3 && lua_isstring(l, 4)) {
		sourceName = lua_tostring(l, 4);
	}

	// Clear the stack
	lua_pop(l, lua_gettop(l));
}

/*
 * Create a new Lua Error object and raise the error
 */
void LuaError::throwError() {
	lua_newtable(l);

	lua_pushinteger(l, errorLevel);
	lua_setfield(l, -2, LEVEL_TAG);

	lua_pushstring(l,errorMessage.c_str());
	lua_setfield(l, -2, ERROR_TAG);

	lua_pushstring(l, sourceName.c_str());
	lua_setfield(l, -2, SCRIPT_TAG);

	lua_pushinteger(l, sourceLine);
	lua_setfield(l, -2, LINE_TAG);

	lua_error(l);
}

/*
 * Extract the source script name from a string of the form: [string "scriptName"]
 */
string LuaError::extractSourceName (const char nameString[]) {
	string s = nameString;
	int q1 = s.find('"');
	int q2 = s.find('"', q1+1);
	return s.substr(q1+1, q2-q1-1);
}

/*
 * Extract the encoded source details from an error message generated by Lua. Typical format is
 * [string "MapTest"]:4:Message
 * Where MapTest is the name of the Script, 4 is the source line of teh error and Message is the error message
 */
void LuaError::extractSourceFromString (const string errorMessage) {
	// cout << "LuaError::extractSourceFromString: error=" << errorMessage << endl;

	int lb = errorMessage.find('[');
	if (lb == 0) {

		sourceName = extractSourceName(errorMessage.c_str());

		// cout << "LuaError::extractSourceFromString: sourceName=" << sourceName << endl;

		int c1 = errorMessage.find(':');
		int c2 = errorMessage.find(':', c1+1);
		string sl = errorMessage.substr(c1+1, c2-c1-1);
		try {
			sourceLine = stoi (sl);
		}
		catch (...) {
			sourceLine = 0;
		}
		// cout << "LuaError::extractSourceFromString: sourceLine=" << sourceLine << endl;

		this -> errorMessage = errorMessage.substr(c2+2, string::npos);
		// cout << "LuaError::extractSourceFromString: errorMessage=" << this->errorMessage << endl;
	}
	else {
		this -> errorMessage = errorMessage;
	}

}

/*
 * Extract the source details from the Lua call stack.
 */
void LuaError::extractSourceFromLua (const string errorMessage) {
	this -> errorMessage = errorMessage;

	// cout << "LuaError::extractSourceFromLua: error=" << errorMessage << endl;

	lua_Debug ar;
	if (lua_getstack(l, STACK_LOOKBACK_LEVEL, &ar)) {
		lua_getinfo(l, "Sl", &ar);
		if (ar.currentline > 0) {
			sourceName = extractSourceName(ar.short_src);
			sourceLine = ar.currentline;
		}
	}

	// cout << "LuaError::extractSourceFromLua: sourceName=" << sourceName << endl;
	// cout << "LuaError::extractSourceFromLua: sourceLine=" << sourceLine << endl;
}


/*
 * Extract the source details from a Lua Error object on the top of the stack
 */
void LuaError::extractSourceFromError (const int stackPos) {

	// cout << "LuaError::extractSourceFromError" << endl;

	lua_getfield(l, stackPos, LEVEL_TAG);
	if (lua_isinteger(l, -1)) {
		errorLevel = (ScriptResult::eResult) lua_tointeger(l, -1);
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, ERROR_TAG);
	if (lua_isstring(l, -1)) {
		errorMessage = lua_tostring(l, -1);
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, SCRIPT_TAG);
	if (lua_isstring(l, -1)) {
		sourceName = lua_tostring(l, -1);
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, LINE_TAG);
	if (lua_isinteger(l, -1)) {
		sourceLine = lua_tointeger(l, -1);
	}
	lua_pop(l, 1);
}

/*
 * Format the error message
 */
string LuaError::formatError() const {
	string error;

	if (sourceName.length() > 0) {
		error = "[" + sourceName + "]:"+to_string(sourceLine)+": ";
	}

	return error + errorMessage;
}

/*
 * Return the Error level associated with this error
 */
ScriptResult::eResult LuaError::getErrorLevel() const {
	return errorLevel;
}

