/*
 * LuaError.cpp
 *
 *  Created on: 24 Aug. 2017
 *      Author: Brent
 */

#include <Lua/lua.hpp>
#include <Scripting/Lua/LuaError.h>
#include <iostream>

using namespace std;

LuaError::LuaError(lua_State *l) {

	this -> l = l;

	setStackLevel(2);
	setErrorLevel(ScriptResult::eResult_Vassal_Error);
	setErrorMessage("");
	setSourceName("");
	setSourceLine(0);
}

LuaError::~LuaError() {
	// TODO Auto-generated destructor stub
}

/*
 * Read any existing Lua error object and the details of the the new error.
 * A Lua error object will exist already if this error is percolating upwards from nested script calls. If
 * a Lua error object exists, then the details in it take precedence over the arguments to raiseError
 */
void LuaError::build() {

	//cout << "LuaError::build: Number of args=" << lua_gettop(l) << ", arg 1 type=" << lua_typename(l, lua_type(l, 1)) << endl;

	// Handle an error object by itself on top of the stack
	if (lua_istable (l, -1)) {
		// cout << "LuaError::build: Table on top of stack, extract data" << endl;
		extractSourceFromError(-1);
		lua_pop(l, lua_gettop(l));
		return;
	}

	int nargs = lua_gettop (l);

	// Handle an error string by itself on top of the stack
	if (nargs == 1 && lua_isstring(l, 1)) {
		extractSourceFromString (lua_tostring(l, 1));
		lua_pop(l, lua_gettop(l));
		return;
	}

	// Otherwise must be 3 or 4 args : Error object, error level, stack level, script name (optional)
	if (nargs < 3 || ! lua_isinteger (l, 3)) {
		string error = "raiseError: Argument 3 is not an integer: ";
		error.append(lua_typename(l, lua_type(l, 3)));
		luaL_error (l, error.c_str());
	}
	setStackLevel(lua_tointeger(l, 3));
	// cout << "LuaError::build: stackLevel=" << stackLevel << endl;

	if (nargs < 2 || ! lua_isinteger (l, 2)) {
		luaL_error (l, "raiseError: Argument 2 is not an integer");
	}
	setErrorLevel((ScriptResult::eResult) lua_tointeger(l, 2));
	// cout << "LuaError::build: errorLevel=" << errorLevel << endl;

	// Is the error object a string?
	if (nargs > 0 && lua_isstring(l, 1)) {
		// cout << "LuaError::build: " << "error is string" << endl;

		string error = lua_tostring(l, 1);
		// cout << "LuaError::build: error string=" << error << endl;

		// Does the Error string already contain source information
		if (error[0] == '[') {
			// Extract the source information from the error string
			extractSourceFromString (error);
		}
		// Some Lua errors return init.lua:99:
		else if (error.find("init.lua") == 0) {
			int colon1pos = error.find(':');
			extractSourceFromLua (error.substr(error.find(':', colon1pos+1)+2, string::npos));
		}
		else {
			// No source info in error string, use the Lua debug module to find it
			extractSourceFromLua (error);
		}

	// Or is the error object a table?
	} else	if (nargs > 0 && lua_istable(l, 1)) {
		// cout << "LuaError::build Error object is table at 1" << endl;
		extractSourceFromError(1);

	} else {
		luaL_error (l, "raiseError: Argument 1 is neither a string or a table");
	}

	// sourceName may have been supplied as a 4th argument
	if (nargs > 3 && lua_isstring(l, 4)) {
		setSourceName(lua_tostring(l, 4));
	}

	// Clear the stack
	lua_pop(l, lua_gettop(l));
}

/*
 * Push a new Lua Error object on to the stack
 */
void LuaError::pushError() const {
	lua_newtable(l);

	lua_pushinteger(l, getErrorLevel());
	lua_setfield(l, -2, LEVEL_TAG);

	lua_pushstring(l,getErrorMessage().c_str());
	lua_setfield(l, -2, ERROR_TAG);

	lua_pushstring(l, getSourceName().c_str());
	lua_setfield(l, -2, SCRIPT_TAG);

	lua_pushinteger(l, getSourceLine());
	lua_setfield(l, -2, LINE_TAG);
}

/*
 * Raise a lua Error
 */
void LuaError::throwError() const {

	// cout << "LuaError::throwError: " << formatError() << endl;
	pushError();
	lua_error(l);
}

/*
 * Extract the source script name from a string of the form: [string "scriptName"]
 */
string LuaError::extractSourceName (const char nameString[]) {
	string s = nameString;
	int q1 = s.find('"');
	int q2 = s.find('"', q1+1);
	return s.substr(q1+1, q2-q1-1);
}

/*
 * Extract the source details from the Lua call stack.
 */
void LuaError::extractSourceFromLua (const string errorMessage) {
	setErrorMessage(errorMessage);

	// cout << "LuaError::extractSourceFromLua: error=" << errorMessage << endl;

	lua_Debug ar;
	if (lua_getstack(l, STACK_LOOKBACK_LEVEL, &ar)) {
		lua_getinfo(l, "Sl", &ar);
		if (ar.currentline > 0) {
			setSourceName(extractSourceName(ar.short_src));
			setSourceLine(ar.currentline);
		}
	}

	// cout << "LuaError::extractSourceFromLua: sourceName=" << sourceName << endl;
	// cout << "LuaError::extractSourceFromLua: sourceLine=" << sourceLine << endl;
}

/*
 * Extract the encoded source details from an error message generated by Lua. Typical format is
 * [string "MapTest"]:4:Message
 * Where MapTest is the name of the Script, 4 is the source line of teh error and Message is the error message
 */
void LuaError::extractSourceFromString (const string errorMessage) {
	// cout << "LuaError::extractSourceFromString: error=" << errorMessage << endl;

	int lb = errorMessage.find('[');
	if (lb == 0) {

		setSourceName(extractSourceName(errorMessage.c_str()));

		// cout << "LuaError::extractSourceFromString: sourceName=" << sourceName << endl;

		int c1 = errorMessage.find(':');
		int c2 = errorMessage.find(':', c1+1);
		string sl = errorMessage.substr(c1+1, c2-c1-1);
		try {
			setSourceLine(stoi (sl));
		}
		catch (...) {
			setSourceLine(0);
		}
		// cout << "LuaError::extractSourceFromString: sourceLine=" << sourceLine << endl;

		setErrorMessage(errorMessage.substr(c2+2, string::npos));
		// cout << "LuaError::extractSourceFromString: errorMessage=" << this->errorMessage << endl;
	}
	else {
		setErrorMessage(errorMessage);
	}

}


/*
 * Extract the source details from a Lua Error object on the top of the stack
 */
void LuaError::extractSourceFromError (const int stackPos) {

	// cout << "LuaError::extractSourceFromError" << endl;

	lua_getfield(l, stackPos, LEVEL_TAG);
	if (lua_isinteger(l, -1)) {
		setErrorLevel((ScriptResult::eResult) lua_tointeger(l, -1));
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, ERROR_TAG);
	if (lua_isstring(l, -1)) {
		setErrorMessage(lua_tostring(l, -1));
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, SCRIPT_TAG);
	if (lua_isstring(l, -1)) {
		setSourceName(lua_tostring(l, -1));
	}
	lua_pop(l, 1);

	lua_getfield(l, stackPos, LINE_TAG);
	if (lua_isinteger(l, -1)) {
		setSourceLine(lua_tointeger(l, -1));
	}
	lua_pop(l, 1);
}

/*
 * Format the error message
 */
string LuaError::formatError() const {
	string error;

	if (getSourceName().length() > 0) {
		error = "[" + getSourceName() + "]:"+to_string(getSourceLine())+": ";
	}

	return error + getErrorMessage();
}

/*
 * Return the Error level associated with this error
 */
ScriptResult::eResult LuaError::getErrorLevel() const {
	return errorLevel;
}

const string& LuaError::getErrorMessage() const {
	return errorMessage;
}

int LuaError::getSourceLine() const {
	return sourceLine;
}

const string& LuaError::getSourceName() const {
	return sourceName;
}

int LuaError::getStackLevel() const {
	return stackLevel;
}

void LuaError::setErrorLevel(ScriptResult::eResult errorLevel) {
	this->errorLevel = errorLevel;
}

void LuaError::setErrorMessage(const string& errorMessage) {
	// cout << "LuaError::setErrorMessage: errorMEssage set to " << errorMessage << endl;
	this->errorMessage = errorMessage;
}

void LuaError::setSourceLine(int sourceLine) {
	this->sourceLine = sourceLine;
}

void LuaError::setSourceName(const string& sourceName) {
	this->sourceName = sourceName;
}

void LuaError::setStackLevel(int stackLevel) {
	this->stackLevel = stackLevel;
}

